R"(
#shader vertex = screen_space
#shader fragment
#uniform Texture2D BaseTexture
#uniform Texture2D AutoExposureTexture
#uniform float Exposure
#uniform float Gamma
#uniform int Type
#uniform int AutoExposureEnable

in vec2 var_UV;

vec3 TonemapSimple(vec3 HDR)
{
	HDR = HDR / (1.0 + HDR);
	return pow(HDR, vec3(1.0 / Gamma));
}

vec3 TonemapFilmic(vec3 HDR)
{
	HDR = max(vec3(0.0), HDR - 0.004);
	return (HDR * (6.2 * HDR + 0.5)) / (HDR * (6.2 * HDR + 1.7) + 0.06);
}

vec3 TonemapACES(vec3 HDR)
{
	const float a = 2.51f;
	const float b = 0.03f;
	const float c = 2.43f;
	const float d = 0.59f;
	const float e = 0.14f;

	HDR = (HDR * (a * HDR + b))  /
	      (HDR * (c * HDR + d) + e);
	HDR = pow(HDR, 1.0 / vec3(Gamma));
	return HDR;
}

vec3 TonemapRomBinDaHouse(vec3 HDR)
{
	HDR = exp(-1.0 / (2.72 * HDR + 0.15));
	return pow(HDR, vec3(1.0 / Gamma));
}

vec3 TonemapUncharted(vec3 HDR)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;

	HDR = ((HDR * (A * HDR + C * B) + D * E) / (HDR * (A * HDR + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	HDR /= white;
	HDR = pow(HDR, vec3(1.0 / Gamma));
	return HDR;
}

void main(void)
{
	float E = Exposure;

	if (AutoExposureEnable == 1)
	{
		E = Sample2D(AutoExposureTexture, vec2(0.5)).r;
	}

	vec3 HDR = clamp(Sample2D(BaseTexture, var_UV).rgb * E, 0, 50000);
	vec3 Mapped = vec3(0.0);

	switch (Type)
	{
	case 0: Mapped = TonemapSimple(HDR); break;
	case 1: Mapped = TonemapFilmic(HDR); break;
	case 2: Mapped = TonemapACES(HDR); break;
	case 3: Mapped = TonemapRomBinDaHouse(HDR); break;
	case 4: Mapped = TonemapUncharted(HDR); break;
	}

	RT0 = vec4(Mapped, 1.0);
}
)"
